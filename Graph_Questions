Q1. Consider a directed graph whose vertices are numbered from 1 to n.
There is an edge from a vertex i to a vertex j iff either j = i + 1 or j = 3 * i.
The task is to find the minimum number of edges in a path in G from vertex 1 to vertex n.

Example 1:

Input:
N = 9
Output:
2
Explanation:
9 -> 3 -> 1, so
number of steps are 2. 
Expected Time Complexity: O(logN)
Expected Auxiliary Space: O(1)

Soultion - 

int minimumstep(int n){
	int count;
	while(n!=1){
		if(n%3==0){
			n = n/3;
		}else{
			n = n-1;
		}
		count++;
	}
	return count;
}

Q2. Find the sum of dependencies in graph.
Given a directed graph with V nodes and E edges. If there is an edge from u to v then u depends on v.
Find out the sum of dependencies for every node. Duplicate edges should be counted as separate edges.

Example 1:

Input:
V=4
E=4
Edges={ {0,2},{0,3},{1,3},{2,3} }
Output:
4
Explanation:
For the graph in diagram, A depends
on C and D i.e. 2, B depends on D i.e.
1, C depends on D i.e. 1
and D depends on none.
Hence answer -> 0 + 1 + 1 + 2 = 4
Expected Time Complexity:O(V)
Expected Auxillary Space:O(1)

Solution->

int SumOfDependencies(vector<int> adj[], int V){
	int sum = 0;
	for(int u=0; u<V; u++){
		sum = sum + adj[u].size();
	}
	return sum;
}

Date: - 9th June 2023

Q3. BFS of graph.
Solution - 

vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        // Code here
        vector<int> v;
        queue<int> q;
        q.push(0);
        vector<bool> vis(V,false);
        vis[0] = true;
        while(!q.empty()){
            int u = q.front();
            q.pop();
            v.push_back(u);
            for(auto it: adj[u]){
                if(!vis[it]){
                    vis[it] = true;
                    q.push(it);
                }
            }
        }
        return v;
    }

Q4. DFS of graph.
Solution -> 

vector<int> v;

void solve(int s, vector<bool> &visited, vector<int> adj[]){
	visited[s] = true;
	v.push_back(s);
	for(int u: adj[s]){
		if(!visited[u]){
			solve(u, visited, adj);	
		}
	}
}

vector<int> DfsOfGraph(int V, vector<int> adj[]){
	vector<bool> visited(V,false);
	for(int i=0;i<V;i++){
		if(visited[i]==false){
			solve(i,visited, adj);
		}
	}
	return v;
}

Q5. Detect a cycle in an undirected graph.
Expected Time Complexity: O(V + E)
Expected Space Complexity: O(V)

Solution ->

bool Dfs_Rec(vector<int> adj[], int s, bool visited[], int parent){
	visited[s] = true;
	for(int u: adj[s]){
		if(visited[u] == false){
			if(Dfs_Rec(adj, u, visited, s)==true){
				return true;
			}
		}else if(u!=parent){
			return true;
		}
	}
	return false;
}
bool isCycle(vector<int> adj[], int V){
	bool visited[V];
	for(int i=0;i<V;i++){
		visited[i] = false;
	}
	for(int i=0;i<V;i++){
		if(visited[i]==false){
			if(Dfs_Rec(adj, i, visited, -1)==true){
				return true;
			}
		}
	}
	return false;
}

Q6. Detect cycle in directed graph.
Expected Time Complexity: O(V + E)
Expected Auxiliary Space: O(V)
Solution ->

bool Dfs_Rec(vector<int>adj[], int s, vector<bool> &visited, vector<bool> &rec_st){
	visited[s] = true;
	rec_st[s] = true;
	for(int u: adj[s]){
		if(visited[u]==false && Dfs_Rec(adj, u, visited, rec_st)==true){
			return true;
		}else if(rec_st[u]==true){
			return true;
		}
	}
	rec_st[s] = false;
	return false;
}
bool isCycle(int V, vector<int> adj[]){
	vector<bool> visited(V,false);
	vector<bool> rec_st(V,false);
	for(int i=0;i<V;i++){
		if(visited[i]==false){
			if(Dfs_Rec(adj, i, visited, rec_st)==true){
				return true;
			}
		}
	}
	return false;	
}

Q7. Topological sort of a graph using kahn's algorithm in BFS based approach.
Solution ->


vector<int> topoSort(int V, vector<int> adj[]){
	vector<int> in(V,0);
	vector<int> ans;
	queue<int> q;
	for(int i=0;i<V;i++){
		for(auto x: adj[i]){
			in[x]++;
		}
	}
	for(int i=0;i<V;i++){
		if(in[i]==0){
			q.push(i);
		}
	}
	while(!q.empty()){
		int u = q.front();
		q.pop();
		ans.push_back(u);
		for(auto x : adj[u]){
			in[x]--;
			if(in[x]==0){
				q.push(x);
			}
		}
	}
	return ans;
}

Q8. Find the number of islands-> https://practice.geeksforgeeks.org/problems/find-the-number-of-islands/
1?page=1&difficulty[]=1&category[]=Graph&sortBy=submissions

Problem statement.
Given a grid of size n*m (n is the number of rows and m is the number of columns in the grid)
consisting of '0's (Water) and '1's(Land). Find the number of islands.
Note: An island is either surrounded by water or boundary of grid and is formed
by connecting adjacent lands horizontally or vertically or diagonally i.e., in all 8 directions.
Example 1:
Input:
grid = {{0,1},{1,0},{1,1},{1,0}}
Output:
1
Explanation:
The grid is-
0 1
1 0
1 1
1 0
All lands are connected.

Example 2: 
Input:
grid = {{0,1,1,1,0,0,0},{0,0,1,1,0,1,0}}
Output:
2
Expanation:
The grid is-
0 1 1 1 0 0 0
0 0 1 1 0 1 0 
There are two islands :- one is colored in blue 
and other in orange.

Solution -> DFS based solution:

void DFS(vector<vector<char>>&grid, int i, int j, int ROW, int COL){
	if(i<0 || j<0 || i>(ROW-1) || j>(COL-1) || grid[i][j] != '1'){
		return;
	}
	if(grid[i][j]=='1'){
		grid[i][j] = 0;
		DFS(grid,i+1,j,ROW,COL);
		DFS(grid,i,j+1,ROW,COL);
		DFS(grid,i-1,j,ROW,COL);
		DFS(grid,i,j-1,ROW,COL);
		DFS(grid,i+1,j+1,ROW,COL);
		DFS(grid,i-1,j-1,ROW,COL);
		DFS(grid,i-1,j+1,ROW,COL);
		DFS(grid,i+1,j-1,ROW,COL);
	}
}
int numIslands(vector<vector<char>>&grid){
	int ROW = grid.size();
	int COL = grid[0].size();
	int count = 0;
	for(int i=0;i<ROW;i++){
		for(int j=0;j<COL;j++){
			if(grid[i][j]=='1'){
				count++;
				DFS(grid, i, j, ROW, COL);
			}
		}
	}
	return count;
}

Q9. Minimum swaps to sort.
https://practice.geeksforgeeks.org/problems/minimum-swaps/1?page=1&difficulty[]=1&category[]=Graph&sortBy=submissions

Given an array of n distinct elements. Find the minimum number of swaps required to sort the array in strictly increasing order.
Input:
nums = {2, 8, 5, 4}
Output:
1
Explaination:
swap 8 with 4.

Example 2:

Input:
nums = {10, 19, 6, 3, 5}
Output:
2
Explaination:
swap 10 with 3 and swap 19 with 5.

Solution -> 

int minSwaps(vector<int>&nums)
	{
	    // Code here
	    int n = nums.size();
	    pair<int,int> arrPos[n];
	    for(int i=0;i<n;i++){
	        arrPos[i].first = nums[i];
	        arrPos[i].second = i;
	    }
	    sort(arrPos,arrPos+n);
	    vector<bool> vis(n,false);
	    int ans = 0;
	    for(int i =0;i<n;i++){
	        if(vis[i] || arrPos[i].second == i){
	            continue;
	        }
	        int cycle_size = 0;
	        int j = i;
	        while(!vis[j]){
	            vis[j] = 1;
	            j = arrPos[j].second;
	            cycle_size++;
	        }
	        if(cycle_size>0){
	            ans = ans + cycle_size-1;
	        }
	    }
	    return ans;
	}

Q10. Detect whether a graph is Bipartite graph or not.

A bipartite graph is a mathematical concept in graph theory that represents a graph
whose vertices can be divided into two disjoint sets such that every edge in the graph
connects a vertex from one set to a vertex in the other set. In other words, there are no
edges that connect vertices within the same set.
Formally, a graph G = (V, E) is bipartite if its vertex set V can be partitioned into two sets,
V1 and V2, such that every edge in E connects a vertex from V1 to a vertex in V2.

Expected Time Complexity: O(V + E)
Expected Space Complexity: O(V)
