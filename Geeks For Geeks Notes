Date -> 10th april 2023.

Q1. Detect the loop in the linked list using floyd's cycle detection method.

Ans -> bool detectLoop(Node* head)
    {
        // your code here
        if(head == NULL || head -> next == NULL){
            return 0;
        }
        Node* slow = head;
        Node* fast = head;
        while(fast -> next && fast -> next -> next){
            slow = slow -> next;
            fast = fast -> next -> next;
            if(slow == fast){
                return 1;
            }
        }
        return 0;
    }
    
Q2. Nth node from end of linked list.
    Input:
    N = 2
    LinkedList: 1->2->3->4->5->6->7->8->9
    Output: 8
    Input:
    N = 5
    LinkedList: 10->5->100->5
    Output: -1
    Answer -> 
    
    int getNthFromLast(Node *head, int n)
{
       // Your code here
       Node* curr = head;
       int count = 0;
       while(curr != NULL){
           curr = curr -> next;
           count++;
       }
       if(n > count){
           return -1;
       }
       count = count - n;
       curr = head;
       for(int i = 0; i < count; i++){
           curr = curr -> next;
       }
       return (curr -> data);
}

Q3. Finding middle element in a linked list

Answer -> int getMiddle(Node *head)
    {
        // Your code here
        Node* curr = head;
        int count = 0;
        while(curr != NULL){
            curr = curr->next;
            count++;
        }
        int middle = 0;
        if(count % 2 == 0){
            middle = count/2;
        }else{
            middle = count/2;
        }
        curr = head;
        for(int i=0;i<middle;i++){
            curr = curr->next;
        }
        return (curr->data);
    }
    
Q4. Reverse a linked list
Input:
LinkedList: 1->2->3->4->5->6
Output: 6 5 4 3 2 1
Explanation: After reversing the list, 
elements are 6->5->4->3->2->1.
Answer -> 

struct Node* reverseList(struct Node *head)
    {
        // code here
        // return head of reversed list
        Node* prev = NULL;
        Node* curr = head;
        while(curr != NULL){
            Node* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
    
   Q5. Flattening the linked list.
   Problem statement -> 
   Given a Linked List of size N, where every node represents a sub-linked-list and contains two pointers:
(i) a next pointer to the next node,
(ii) a bottom pointer to a linked list where this node is head.
Each of the sub-linked-list is in sorted order.
Flatten the Link List such that all the nodes appear in a single level while maintaining the sorted order. 

Note: The flattened list will be printed using the bottom pointer instead of the next pointer.
For more clarity have a look at the printList() function in the driver code.

 

Example 1:

Input:
5 -> 10 -> 19 -> 28
|     |     |     | 
7     20    22   35
|           |     | 
8          50    40
|                 | 
30               45
Output:  5-> 7-> 8- > 10 -> 19-> 20->
22-> 28-> 30-> 35-> 40-> 45-> 50.
Explanation:
The resultant linked lists has every 
node in a single level.
(Note: | represents the bottom pointer.)

   Solution -> 
   
   Node* mergeTwoLists(Node* a ,Node* b){
    Node* temp = new Node(0);
    Node* res = temp;
    
    while(a != NULL && b != NULL){
        if(a->data < b->data){
            temp->bottom = a;
            temp = temp->bottom;
            a = a->bottom;
        }else{
            temp->bottom = b;
            temp = temp->bottom;
            b = b->bottom;
        }
        if(a) temp->bottom = a;
        else temp->bottom = b;
    }
    return res->bottom;
}
Node *flatten(Node *root)
{
   // Your code here
   if(root == NULL || root->next == NULL){
       return root;
   }
   root->next = flatten(root->next);
   root = mergeTwoLists(root, root->next);
   
   return root;
}
    
    Q7. Given a linked list, we need to cancel out all the resources whose sum is equal
        to zero and return the remaining linked list.
        
        Input =  6 -6 8 4 -12 9 8 -8
        Nodes which get cancelled out are:
        6 -6
        8 4 -12
        8 -8
        Output = 9
        
        Input = 4 6 -10 8 9 10 -19 10 -18 20 25.
        Output = 20 25
        
    Solution ->  
        
        Node removeCancellableNodes(Node listHead)
{
	if (listHead == null) return null; // or listHead
	Stack<Node> stack = new Stack<Node>();
	Node node = listHead;  	
	while(node != null)
	{
		if (node.value < 0)
		{
			int sum = node.value;
                        while (!stack.isEmpty())
			{
				Node temp = stack.pop();
				sum -= temp.value;
				temp = null;
				if (sum == 0)
				{
					node = stack.peek();
					break;
				}
			}
		}
		else
		{
			stack.push(node);
		}
		node = node.next;
	}
	
	return listHead;
}

Q8. Add 1 to a number represented as linked list.
A number N is represented in Linked List such that each digit corresponds to a node in linked list. You need to add 1 to it.

Example 1:

Input:
LinkedList: 4->5->6
Output: 457 

Solution -> 
1. Reverse given linked list. For example, 1-> 9-> 9 -> 9 is converted to 9-> 9 -> 9 ->1.
2. Start traversing linked list from leftmost node and add 1 to it.
   If there is a carry, move to the next node. Keep moving to the next node while 
   there is a carry.
3. Reverse modified linked list and return head.

class Solution
{
    public:
    Node* reverse(Node* head){
        Node* prev = NULL;
        Node* current = head;
        Node* next;
        while(current != NULL){
            next = current->next;
            current->next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }
    Node* addOneUntil(Node* head){
        Node* res = head;
        Node* temp;
        int carry = 1, sum;
        while(head != NULL){
            sum = carry + head->data;
            if(sum>=10){
                carry = 1;
            }else{
                carry = 0;
            }
            sum = sum%10;
            head->data = sum;
            temp = head;
            head = head->next;
        }
        if(carry>0){
            temp->next = new Node(carry);
        }
        return res;
    }
    Node* addOne(Node *head) 
    {
        // Your Code here
        // return head of list after adding one
        head = reverse(head);
        head = addOneUntil(head);
        return reverse(head);
    }
};
